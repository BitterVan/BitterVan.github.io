{"meta":{"title":"Xingkai Wang","subtitle":null,"description":"","author":"Xingkai Wang","url":"http://bittervan.github.io","root":"/"},"pages":[{"title":"","date":"2024-08-04T07:28:22.369Z","updated":"2024-08-04T07:28:22.369Z","comments":true,"path":"index.html","permalink":"http://bittervan.github.io/index.html","excerpt":"","text":"About MeMy name is Xingkai Wang (王行楷). I am interested in system optimization and hardening, especially via exploiting the potential of next-generation hardware or novel microarchitectures. I get my bachelor degree at Computer Science in June, 2023. I am currently in Zhejiang University as a master student at Cyber Security. Here is my resume."},{"title":"categories","date":"2023-04-01T11:27:24.000Z","updated":"2024-08-04T07:28:22.333Z","comments":true,"path":"categories/index.html","permalink":"http://bittervan.github.io/categories/index.html","excerpt":"","text":""},{"title":"Xingkai Wang","date":"2023-04-01T11:27:40.000Z","updated":"2024-08-04T07:28:22.333Z","comments":true,"path":"about/index.html","permalink":"http://bittervan.github.io/about/index.html","excerpt":"","text":"I am an undergraduate student in Computer Science at Zhejiang University working on my undergraduate thesis."},{"title":"","date":"2024-08-04T07:28:22.369Z","updated":"2024-08-04T07:28:22.369Z","comments":true,"path":"publications/index.html","permalink":"http://bittervan.github.io/publications/index.html","excerpt":"","text":"PublicationsDMAAUTH: A Lightweight Pointer Integrity-based Secure Architecture to Defeat DMA Attacks USENIX Security' Xingkai Wang, Wenbo Shen, Yujie Bu, Jinmeng Zhou, Yajin Zhou 24 Designed hardware-software co-design to perform access authentication for all the DMA transactions, providing fine-grained spatial and strong temporal legitimacy guarantees. Used hardware description languages to integrate the solution between the PCIe bus and memory controller. Evaluated the implemetation with real-world hardware connected to RISC-V SoC on FPGA. Conducted detailed characterization about DMA transactions revealing access pecularity. Implemented both RISC-V and ARM QEMU emulators to show cross-architecture capability. Provided a fully customizable research platform for the community to study DMA and host-peripheral interactions, contributing to enhanced security in modern computing systems. Ambush from All Sides: Understanding Security Threats in Open-Source Software CI&#x2F;CD Pipelines TDSC' Ziyue Pan, Wenbo Shen, Xingkai Wang, Yutian Yang, Rui Chang, Yao Liu, Chengwei Liu, Yang Liu, Kui Ren 23 Analyzed potential vulnerabilities, such as information leakage, remote code execution, and pipeline output modification. Developed proof-of-concept attacks and proposed mitigations. Conducted a large-scale analysis of over 300,000 GitHub repositories and 8,000 unique scripts created by more than 5000 developers, providing dataset for future CI&#x2F;CD related researchs."},{"title":"tags","date":"2023-04-01T11:26:17.000Z","updated":"2024-08-04T07:28:22.373Z","comments":true,"path":"tags/index.html","permalink":"http://bittervan.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"How Can MicroPython Run Like A OS?","slug":"micropython-explore","date":"2022-04-16T09:48:10.000Z","updated":"2024-08-04T07:28:22.325Z","comments":true,"path":"2022/04/16/micropython-explore/","permalink":"http://bittervan.github.io/2022/04/16/micropython-explore/","excerpt":"在本文中记录我们以 MicroPython 和 REPL 的交互为例，探索 MicroPython 为什么能和一个 OS 一样做到被事件驱动，而非顺序执行。","text":"在本文中记录我们以 MicroPython 和 REPL 的交互为例，探索 MicroPython 为什么能和一个 OS 一样做到被事件驱动，而非顺序执行。 现象 在 esp32 上执行如下代码 1234import webreplwebrepl.start()while True: print(&quot;loop&quot;) 后，使用 webrepl 客户端进行连接，无法在板上 serial port 和 webrepl console 中看到任何相关内容 在执行完 webrepl.start() 后，没有开始循环时，使用 webrepl 客户端进行连接，连接成功后，再开始循环，loop 会输出到 serial port 和 webrepl console 中 如果执行的是这样的代码 123456import webreplimport timewebrepl.start()while True: print(&quot;loop&quot;) time.sleep_ms(1000) 则即使在循环开始以后，也能够通过 webrepl 连接上 在循环开始后，使用 serial 连接的终端模拟器可以直接通过 Ctrl + C 而 webrepl console 中就无法做到 在加入了 time.sleep_ms(1000) 的代码被加入后，在 webrepl 中也能够使用 Ctrl + C 来将循环打断 一些前期猜想 MicroPython 是直接跑在 MicroPython 上的，通过中断进行一切事件驱动（无法解释死循环中无法响应 webrepl 请求） MicroPython 是跑在 RTOS 上的，通过 RTOS 的线程级调度来实现并发，这样也能够做到事件驱动（还是无法解释死循环中无法响应 webrepl 请求） MicroPython 是个单线程程序，直接由自身通过轮询去处理所有的事件（这样的确可以在要输出的时候去查看所有连接上的 console，但是能输出不能接收又显得太过古怪，至少在输出的时候可以通过查看所有事件来发现要接收的信号） 到这里我们已经觉得把 MicroPython 当成黑箱去分析得出的结果可能非常不靠谱，所以我们从源码入手，尝试解释我们实验中遇到的现象。 实际实现我们烧录进去的二进制文件包括了 RTOS 和 MicroPython，它们一共使用三种方式来实现事件驱动： Baremetal 进行中断响应通过设置片上中断来进行中断响应，达到打断程序的目的。这样可以非常自由地进行操作，例如收到了 uart 的输入后，可以直接将这些输入送给 MicroPython 的 stream。这里的响应是最底层的。在这一层，MCU 和我们使用的计算机十分相似，我们完全可以用理解 PC 中断的方式来理解 esp32 的中断。 在 MicroPython 最先开始在 FreeRTOS 上运行的时候，进行了一些初始化操作，其中进行了中断设置。我们发现 12345678void app_main(void) &#123; // Hook for a board to run code at start up. // This defaults to initialising NVS. MICROPY_BOARD_STARTUP(); // Create and transfer control to the MicroPython task. xTaskCreatePinnedToCore(mp_task, &quot;mp_task&quot;, MP_TASK_STACK_SIZE / sizeof(StackType_t), NULL, MP_TASK_PRIORITY, &amp;mp_main_task_handle, MP_TASK_COREID);&#125; 函数启动了主线程函数 mp_task，在其开始运行的时候 1234567891011121314void mp_task(void *pvParameter) &#123; volatile uint32_t sp = (uint32_t)get_sp(); #if MICROPY_PY_THREAD mp_thread_init(pxTaskGetStackStart(NULL), MP_TASK_STACK_SIZE / sizeof(uintptr_t)); #endif #if CONFIG_USB_ENABLED usb_init(); #elif CONFIG_ESP_CONSOLE_USB_SERIAL_JTAG usb_serial_jtag_init(); #else uart_stdout_init(); #endif machine_init(); ... 进行了这些初始化操作，而通过串口输出的 loop 会因为 Ctrl + C 而停止，键盘输入没有因为死循环而被禁用，就是因为这里调用 uart_stdout_init 进行了初始化 123456789101112131415161718192021void uart_stdout_init(void) &#123; uart_config_t uartcfg = &#123; .baud_rate = MICROPY_HW_UART_REPL_BAUD, .data_bits = UART_DATA_8_BITS, .parity = UART_PARITY_DISABLE, .stop_bits = UART_STOP_BITS_1, .flow_ctrl = UART_HW_FLOWCTRL_DISABLE, .rx_flow_ctrl_thresh = 0 &#125;; uart_param_config(MICROPY_HW_UART_REPL, &amp;uartcfg); const uint32_t rxbuf = 129; // IDF requires &gt; 128 min const uint32_t txbuf = 0; uart_driver_install(MICROPY_HW_UART_REPL, rxbuf, txbuf, 0, NULL, 0); uart_isr_handle_t handle; uart_isr_free(MICROPY_HW_UART_REPL); uart_isr_register(MICROPY_HW_UART_REPL, uart_irq_handler, NULL, ESP_INTR_FLAG_LOWMED | ESP_INTR_FLAG_IRAM, &amp;handle); uart_enable_rx_intr(MICROPY_HW_UART_REPL);&#125; 而这其中的函数 uart_driver_install 是一个 esp-idf 库函数，我们可以在官方文档中找到它的功能 这个函数将对应的中断响应程序 install 到内存的某个部分来等待中断。 RTOS 进行线程级调度此外，MicroPython 本身并不是一个单线程的程序，它也会通过 FreeROTS 的线程来执行自己的函数。比如在上面提到的，在一个没有 delay 的循环中，输出的内容仍然会被送到 webrepl 客户端，这是通过在 FreeRTOS 上 spawn 出来的线程来发送的。 123456789STATIC mp_obj_t ppp_connect_py(size_t n_args, const mp_obj_t *args, mp_map_t *kw_args) &#123; enum &#123; ARG_authmode, ARG_username, ARG_password &#125;; ... if (xTaskCreatePinnedToCore(pppos_client_task, &quot;ppp&quot;, 2048, self, 1, (TaskHandle_t *)&amp;self-&gt;client_task_handle, MP_TASK_COREID) != pdPASS) &#123; mp_raise_msg(&amp;mp_type_RuntimeError, MP_ERROR_TEXT(&quot;failed to create worker task&quot;)); &#125; return mp_const_none;&#125; 在这里 spawn 出了一个线程，执行的是 pppos_client_task ，这个 task 123456789101112131415static void pppos_client_task(void *self_in) &#123; ppp_if_obj_t *self = (ppp_if_obj_t *)self_in; uint8_t buf[256]; while (ulTaskNotifyTake(pdTRUE, 0) == 0) &#123; int err; int len = mp_stream_rw(self-&gt;stream, buf, sizeof(buf), &amp;err, 0); if (len &gt; 0) &#123; pppos_input_tcpip(self-&gt;pcb, (u8_t *)buf, len); &#125; &#125; self-&gt;client_task_handle = NULL; vTaskDelete(NULL);&#125; 的功能就是不断从 MicroPython 的 I&#x2F;O stream 中取东西，交由 PPP 来进行处理。由于是另一个线程，会被 FreeRTOS 调度出来，也就不会被 MicroPython 主线程上的循环给 block 住了。 MicroPython 进行事件响应那么为什么对 webrepl server 的连接请求又会被 block 呢？MicroPython 内部还有一套原生的 Event 系统，这些 events 会在特定的时候被放到 MicroPython 的 foreground 来运行。还是以 webrepl 为例，等待 webrepl client 的连接请求显然是被放到了 background 中的，而无法在没有 sleep 的循环中直接被响应又告诉我们这并不在另一个线程上运行，也并非中断。 MicroPython 本身维护了一个链表，记录着那些需要被处理的回调函数 1234567891011121314151617def setup_conn(port, accept_handler): global listen_s listen_s = socket.socket() listen_s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) ai = socket.getaddrinfo(&quot;0.0.0.0&quot;, port) addr = ai[0][4] listen_s.bind(addr) listen_s.listen(1) if accept_handler: listen_s.setsockopt(socket.SOL_SOCKET, 20, accept_handler) for i in (network.AP_IF, network.STA_IF): iface = network.WLAN(i) if iface.active(): print(&quot;WebREPL daemon started on ws://%s:%d&quot; % (iface.ifconfig()[0], port)) return listen_s 这段 Python 代码调用了一个用 C 语言编写的函数 1234567891011121314151617181920212223STATIC mp_obj_t socket_setsockopt(size_t n_args, const mp_obj_t *args) &#123; ... #if MICROPY_PY_USOCKET_EVENTS // level: SOL_SOCKET // special &quot;register callback&quot; option case 20: &#123; if (args[3] == mp_const_none) &#123; if (self-&gt;events_callback != MP_OBJ_NULL) &#123; usocket_events_remove(self); self-&gt;events_callback = MP_OBJ_NULL; &#125; &#125; else &#123; if (self-&gt;events_callback == MP_OBJ_NULL) &#123; usocket_events_add(self); &#125; self-&gt;events_callback = args[3]; &#125; break; &#125; #endif ... return mp_const_none;&#125; 这里将自己这个 socket 对象添加到 events 链表中，调用的是函数 usocket_events_add. 1234STATIC void usocket_events_add(socket_obj_t *sock) &#123; sock-&gt;events_next = usocket_events_head; usocket_events_head = sock;&#125; 将事件添加到链表头。而处理这些回调函数（事件）的，是在主线程中主动调用的函数，使用了类似轮询的方式，不断查看有没有需要处理的事件。比如处理 usocket 事件的 1234567891011121314151617181920212223242526272829303132void usocket_events_handler(void) &#123; if (usocket_events_head == NULL) &#123; return; &#125; if (--usocket_events_divisor) &#123; return; &#125; usocket_events_divisor = USOCKET_EVENTS_DIVISOR; fd_set rfds; FD_ZERO(&amp;rfds); int max_fd = 0; for (socket_obj_t *s = usocket_events_head; s != NULL; s = s-&gt;events_next) &#123; FD_SET(s-&gt;fd, &amp;rfds); max_fd = MAX(max_fd, s-&gt;fd); &#125; // Poll the sockets struct timeval timeout = &#123; .tv_sec = 0, .tv_usec = 0 &#125;; int r = select(max_fd + 1, &amp;rfds, NULL, NULL, &amp;timeout); if (r &lt;= 0) &#123; return; &#125; // Call the callbacks for (socket_obj_t *s = usocket_events_head; s != NULL; s = s-&gt;events_next) &#123; if (FD_ISSET(s-&gt;fd, &amp;rfds)) &#123; mp_call_function_1_protected(s-&gt;events_callback, s); &#125; &#125;&#125; 就在每次被调用到的时候取处理我们添加到链表中的 events. 而在很多函数中，我们都能够找到这个函数以宏的形式得到了调用 123456789#define MICROPY_EVENT_POLL_HOOK \\do &#123; \\ extern void mp_handle_pending(bool); \\ mp_handle_pending(true); \\ MICROPY_PY_USOCKET_EVENTS_HANDLER \\ MP_THREAD_GIL_EXIT(); \\ ulTaskNotifyTake(pdFALSE, 1); \\ MP_THREAD_GIL_ENTER(); \\&#125; while (0); 在这些地方，都会检查是否有还未被处理的 event，然后直接由主线程进行处理。较为典型的，有在 repl 获取命令时的 mp_task() --&gt; pyexec_friendly_repo() --&gt; readline() --&gt; mp_hal_stdin_rx_chr() 中，就使用了这个宏 123456789int mp_hal_stdin_rx_chr(void) &#123; for (;;) &#123; int c = ringbuf_get(&amp;stdin_ringbuf); if (c != -1) &#123; return c; &#125; MICROPY_EVENT_POLL_HOOK &#125;&#125; 我们在来看 time.sleep_ms 的实现 1234567STATIC mp_obj_t time_sleep_ms(mp_obj_t arg) &#123; mp_int_t ms = mp_obj_get_int(arg); if (ms &gt;= 0) &#123; mp_hal_delay_ms(ms); &#125; return mp_const_none;&#125; 而这里调用的 mp_hal_delay_ms 中，又有查询 socket 中事件的宏 123456789101112131415161718192021222324252627void mp_hal_delay_ms(uint32_t ms) &#123; uint64_t us = ms * 1000; uint64_t dt; uint64_t t0 = esp_timer_get_time(); for (;;) &#123; mp_handle_pending(true); MICROPY_PY_USOCKET_EVENTS_HANDLER MP_THREAD_GIL_EXIT(); uint64_t t1 = esp_timer_get_time(); dt = t1 - t0; if (dt + portTICK_PERIOD_MS * 1000 &gt;= us) &#123; // doing a vTaskDelay would take us beyond requested delay time taskYIELD(); MP_THREAD_GIL_ENTER(); t1 = esp_timer_get_time(); dt = t1 - t0; break; &#125; else &#123; ulTaskNotifyTake(pdFALSE, 1); MP_THREAD_GIL_ENTER(); &#125; &#125; if (dt &lt; us) &#123; // do the remaining delay accurately mp_hal_delay_us(us - dt); &#125;&#125; 所以我们在进行 time.sleep_ms 的时候，也能够响应 socket 的事件。 综上，MicroPython 用三种不同的机制来实现了类似事件驱动的效果。感觉这样做似乎并不太 elegant，但可能出于性能考虑选取的最优解，三种方式的开销也确实一种比一种小。本次阅读 MicroPython 源码使我们获益良多。（虽然他们把 initializer 拼成 initialiser） boot.py, main.py 的运行运行这两个文件的代码也在 mp_task 中 1234567891011121314void mp_task(void *pvParameter) &#123; ... // run boot-up scripts pyexec_frozen_module(&quot;_boot.py&quot;); pyexec_file_if_exists(&quot;boot.py&quot;); if (pyexec_mode_kind == PYEXEC_MODE_FRIENDLY_REPL) &#123; int ret = pyexec_file_if_exists(&quot;main.py&quot;); if (ret &amp; PYEXEC_FORCED_EXIT) &#123; goto soft_reset_exit; &#125; &#125; ... goto soft_reset;&#125; 最后这个文件中读出来的内容都去调了这个函数 123int pyexec_file(const char *filename) &#123; return parse_compile_execute(filename, MP_PARSE_FILE_INPUT, EXEC_FLAG_SOURCE_IS_FILENAME);&#125; 和 REPL 中我们的输入共用一个函数，只是改变了一个参数，这个参数仅带来 parse 的不同 12345678910111213141516mp_parse_tree_t mp_parse(mp_lexer_t *lex, mp_parse_input_kind_t input_kind) &#123; ... // work out the top-level rule to use, and push it on the stack size_t top_level_rule; switch (input_kind) &#123; case MP_PARSE_SINGLE_INPUT: top_level_rule = RULE_single_input; break; case MP_PARSE_EVAL_INPUT: top_level_rule = RULE_eval_input; break; default: top_level_rule = RULE_file_input; &#125; push_rule(&amp;parser, lex-&gt;tok_line, top_level_rule, 0); ... 运行这两个文件的方式不过是读出来然后直接解释执行。","categories":[],"tags":[{"name":"Embedded System","slug":"Embedded-System","permalink":"http://bittervan.github.io/tags/Embedded-System/"}]},{"title":"WebSocket Cannot Be Established Due to Proxy","slug":"webrepl-fail-on-proxy","date":"2022-03-31T10:20:15.000Z","updated":"2024-08-04T07:28:22.333Z","comments":true,"path":"2022/03/31/webrepl-fail-on-proxy/","permalink":"http://bittervan.github.io/2022/03/31/webrepl-fail-on-proxy/","excerpt":"I’ve been working on building a visual studio code extension for a better-developing experience on ESP32, MicroPython. But without any basic knowledge of front-end development, this process is quite tough for me. To establish a wireless connection, the first thing that came to my mind is that I should check the official tools. So I checked the source code of project webrepl, a WebREPL terminal client, which also has a coarse front-end written in Javascript.","text":"I’ve been working on building a visual studio code extension for a better-developing experience on ESP32, MicroPython. But without any basic knowledge of front-end development, this process is quite tough for me. To establish a wireless connection, the first thing that came to my mind is that I should check the official tools. So I checked the source code of project webrepl, a WebREPL terminal client, which also has a coarse front-end written in Javascript. ProblemIt seemed to be simple to connect to the webrepl server running on the board, as the code in webrepl.html showed. But when I was using the npm package ws or websocket in Typescript to connect to it, the connection was simply cannot be established. The error in the serial connection illustrated that 1234567Traceback (most recent call last): File &quot;webrepl.py&quot;, line 43, in accept_conn File &quot;websocket_helper.py&quot;, line 39, in server_handshakejOSError: Not a websocket requestWebREPL connection from: (&#x27;192.168.137.1&#x27;, 2935) At first, I thought it was just like ordinary problems, parameters, policies, etc. So I applied WireShark to check the difference between the packets sent by webrepl and the Typescript extension written by myself. Using the ws package to connect: Using Javascript WebSocket to connect to the board: Having no idea which options to alter, I referred to the MicroPython project to find out. But the code shows that’s nothing to do with the options. 1234567891011121314151617webkey = Nonewhile 1: l = clr.readline() if not l: raise OSError(&quot;EOF in headers&quot;) if l == b&quot;\\r\\n&quot;: break # sys.stdout.write(l) h, v = [x.strip() for x in l.split(b&quot;:&quot;, 1)] if DEBUG: print((h, v)) if h == b&quot;Sec-WebSocket-Key&quot;: webkey = vif not webkey: raise OSError(&quot;Not a websocket request&quot;) But how can webkey == None happen? The two packets both have Sec-WebSocket-Key in their fields. SolutionFortunately, one of my teammates found that the client was assigned with Go-client, and it was our proxy server Clash For Windows that modified our packet. And turning off the proxy worked.","categories":[],"tags":[{"name":"Embedded System","slug":"Embedded-System","permalink":"http://bittervan.github.io/tags/Embedded-System/"}]}],"categories":[],"tags":[{"name":"Embedded System","slug":"Embedded-System","permalink":"http://bittervan.github.io/tags/Embedded-System/"}]}